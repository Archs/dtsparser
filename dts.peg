package main

import "github.com/Archs/dtsparser/dts"

type Parser Peg {
	dts.DTS
}

start
	<- SPACE (ModuleDeclaration 
	          / ClassDeclaration 
	          / InterfaceDeclaration
	          / AssignmentDeclaration
	          / VariableDeclaration
	          / FuncDeclaration )+ eof

ModuleDeclaration
	<- modifier? ModuleIdentifier ModuleBody

ModuleBody
	<- block_start 
		   (ClassDeclaration
		   	/ InterfaceDeclaration
		   	/ ModuleDeclaration
			/ VariableDeclaration
			/ FuncDeclaration
			/ AssignmentDeclaration)*
	   block_end

AssignmentDeclaration
	<- AssignmentModifier? identifier? AssignmentSeparator AssignmentValue DeclarationSeperator

AssignmentModifier
	<- (('declare' / 'export' / 'private' / 'static' 
	    / 'import' / "var" / "function" / 'type') SPACE)+

AssignmentValue
	<- value (Or value)* 

AssignmentSeparator
	<- SPACE '=' SPACE

Or
	<- SPACE '|' SPACE

ClassDeclaration
	<- modifier? ClassIdentifier ExtendClause? ImplementClause? ClassBody 

InterfaceDeclaration
	<- modifier? InterfaceIdentifier ExtendClause? InterfaceBody 

ModuleIdentifier
	<- 'module' SPACE <fakeIdentifier> { p.NewModule(text) }

ClassIdentifier
	<- 'class' SPACE <GenericIdentifier> { p.NewClass(text) }

InterfaceIdentifier
	<- 'interface' SPACE <GenericIdentifier> { p.NewInterface(text) }

ClassBody
	<- block_start
			(VariableDeclaration / FuncDeclaration)* 
	   block_end

InterfaceBody
	<- block_start
			(VariableDeclaration 
			 / FuncDeclaration 
			 / (FuncType DeclarationSeperator)
			 / IndexDeclaration)* 
	   block_end

IndexDeclaration
	<- square_start
			VariableDifinition
	   square_end
	   TypeSeperator
	   Type
	   DeclarationSeperator

ExtendClause
	<- SPACE 'extends' SPACE GenericIdentifier (ArgumentSeperator GenericIdentifier)*

ImplementClause
	<- SPACE 'implements' SPACE identifier (ArgumentSeperator identifier)*

VariableDeclaration
	<- <modifier? VariableDifinition> DeclarationSeperator {p.NewVariable(buffer[begin:end])}

FuncDeclaration
	<- <modifier? identifier FuncType> DeclarationSeperator {p.NewFunction(buffer[begin:end])}

Type
	<- ('typeof' SPACE)? (BasicType (Or BasicType)*)

GenericIdentifier
	<- identifier GenericForm?

GenericType
	<- identifier GenericForm

GenericForm
	<- g_start
	   	genericDecl (ArgumentSeperator genericDecl)*
	   g_end

genericDecl
	<- Type (SPACE 'extends' SPACE Type)?

BasicType
	<- ArrayType
		/ GenericType
		/ FixedArrayType
		/ ObjectType 
		/ ParenFunc
		/ FuncType 
		/ "number" 
		/ "boolean"
		/ "string"
		/ "function"
		/ "any"
		/ LiteralType
		/ identifier

ParenFunc
	<- paren_start 
			FuncType
	   paren_end 

FuncType
	<- GenericForm? paren_start 
			VariableDifinition? (ArgumentSeperator VariableDifinition)*
	   paren_end 
	   (( FuncReturn / TypeSeperator) Type)?

FixedArrayType
	<- square_start
			Type (ArgumentSeperator Type)*
	   square_end

ArrayType
	<-  (GenericType
		/ FixedArrayType
		/ ObjectType 
		/ ParenFunc
		/ FuncType 
		/ "number" 
		/ "boolean"
		/ "string"
		/ "function"
		/ "any"
		/ LiteralType
		/ identifier) '[]'+

ObjectType
	<- block_start
			((ObjectKey TypeSeperator Type DeclarationSeperator)
			 / FuncDeclaration
			 / FuncType DeclarationSeperator)*
	   block_end

ObjectKey
	<- identifier / SquareKey

SquareKey
	<- square_start
			identifier TypeSeperator Type
	   square_end   

LiteralType
	<- string

VariableDifinition
	<- identifier TypeSeperator Type

TypeSeperator
	<- SPACE ':' SPACE

FuncReturn
	<- SPACE '=>' SPACE

ArgumentSeperator
	<- SPACE ',' SPACE

DeclarationSeperator
	<- ((';' / eol)? SPACE)?

keywords
	<- 'module' / 'class' / 'interface' / 'extends' / 'implements'
		/ 'boolean' / 'number' / 'string' / 'void'

modifier
	<- (('declare' / 'export' / 'private' / 'static' 
	    / 'import' / "var" / "function") SPACE)+

fakeIdentifier
	<- ([[A-Z]]/[_.$'"]) ([[A-Z]]/[0-9]/[_?.$<>'"])*

identifier
	<- ([[A-Z]]/[_.$]) ([[A-Z]]/[0-9]/[_?.$])*

value
	<- Type / fcall / number / string

# value for function call
fcall
	<- identifier
	   paren_start
	   		value (ArgumentSeperator value)*
	   paren_end

number
	<- [+-]? [0-9] [.]? [0-9]*

string
	<- ['] ( [[A-Z]] / [_.$] ) ( [[A-Z]] / [0-9]  /[_?.$<>] / '-' )* [']
	  /["] ( [[A-Z]] / [_.$] ) ( [[A-Z]] / [0-9]  /[_?.$<>] / '-' )* ["]


separator
	<- [:;(){},\[\]=>]

Comment
	<- LineComment / BlockComment

LineComment
	<- '//' (!eol .)* eol

BlockComment
	<- '/*' (!'*/' .)* '*/'

block_start
	<- SPACE '{' SPACE

block_end
	<- SPACE '}' SPACE

paren_start
	<- SPACE '(' SPACE

paren_end
	<- SPACE ')' SPACE

square_start
	<- SPACE '[' SPACE

square_end
	<- SPACE ']' SPACE

g_start
	<- SPACE '<' SPACE

g_end
	<- SPACE '>' SPACE

SPACE
	<- spacing* 

ws				<- [ \t\n\r]
spacing         <- [ \t\n\r] / Comment
eol             <- '\n'
eof             <- !.
